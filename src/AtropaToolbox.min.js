/*jslint
    indent: 4,
    maxerr: 50,
    white: true,
    browser: true,
    devel: true,
    plusplus: true,
    regexp: true,
    vars: true
*/
/*global XPathResult, module */
// end header
var atropa;
atropa = {};
atropa.supportCheck = function (className, errorMessage) {
    'use strict';
    className = String(className);
    errorMessage = errorMessage || atropa.data[className].error;
    errorMessage = String(errorMessage);
    if (atropa.data[className].support === 'unsupported') {
        throw new Error(errorMessage);
    }
};
atropa.requires = function (className, requirementFn, errorMessage) {
    'use strict';
    var check = function () {
        var test = false;
        if (typeof className !== 'string') {
            throw new Error('atropa.requires requires the class name to be ' + 'specified');
        }
        if (atropa.data[className] === undefined) {
            atropa.data[className] = {};
            if (typeof requirementFn !== 'function') {
                requirementFn = false;
            }
            if (typeof errorMessage !== 'string') {
                errorMessage = 'The atropa.' + className + ' class is unsupported in this environment.';
            }
            try {
                test = requirementFn();
            } catch (e) {
                test = false;
            }
            atropa.data[className].error = errorMessage;
            if (test === false) {
                atropa.data[className].support = 'unsupported';
            }
        }
    };
    atropa.data.requirements.push(check);
};
atropa.data = {};
atropa.data.requirements = [];
atropa.nop = function nop() {
    'use strict';
    return null;
};
atropa.ArgsInfo = function ArgsInfo() {
    'use strict';
    var expectedArgTypes, checkArgs, that;
    that = this;
    expectedArgTypes = {};
    this.setExpectedArgTypes = function setExpectedArgTypes(typesObj) {
        var error, names;
        error = false;
        if (atropa.inquire.isObjectNotNull(typesObj)) {
            names = Object.keys(typesObj);
            if (names.length > 0) {
                expectedArgTypes = typesObj;
            } else {
                error = true;
            }
        } else {
            error = true;
        }
        if (error) {
            throw new atropa.InvalidArgumentTypesError('typesObj is expected to be of the form: var typesObj = ' + '{ "namedArgumentTypesArray" : ' + '    ["string", "function", "number"], ' + '"namedAlternateArgumentTypesArray" : ' + '   ["object", "function", "number"] }; ' + 'You may use as many named arrays as you wish and' + 'checkArgTypes will test for a match to at least one of the ' + 'provided named arrays.');
        }
    };
    this.getArgTypes = function getArgTypes(args) {
        var x, argTypes;
        argTypes = [];
        for (x in args) {
            if (args.hasOwnProperty(x)) {
                argTypes.push(typeof args[x]);
            }
        }
        return argTypes;
    };
    checkArgs = function checkArgs(expectedTypesArray, args) {
        var types;
        types = {};
        types.expected = expectedTypesArray;
        types.received = that.getArgTypes(args);
        return atropa.arrays.match(types.expected, types.received);
    };
    this.checkArgTypes = function checkArgTypes(args) {
        var expectedTypes;
        if (Object.keys(expectedArgTypes).length < 1) {
            throw new atropa.InvalidArgumentTypesError('Expected argument types is not set. Use ' + 'setExpectedArgTypes(typesObj) to set. typesObj is an ' + 'object whose properties are arrays of strings representing ' + 'the typeof(argument) for each argument, in the exact order ' + 'in which they will be given to the function. Using multiple ' + 'properties it is possible to define alternative acceptable ' + 'argument type sets. Use getArgTypes(arguments) as a ' + 'convenient way of getting the array you want to hard code ' + 'in for validation. Example: var typesObj = ' + '{ "messageIncluded" : ["string", "function", "number"], ' + '"messageNotIncluded" : ["object", "function", "number"] };');
        }
        for (expectedTypes in expectedArgTypes) {
            if (expectedArgTypes.hasOwnProperty(expectedTypes)) {
                if (checkArgs(expectedArgTypes[expectedTypes], args)) {
                    return expectedTypes;
                }
            }
        }
        throw new atropa.InvalidArgumentTypesError('invalid argument type @ atropa.ArgsInfo.checkArgTypes');
    };
};
atropa.arrays = {};
atropa.arrays.match = function arraysMatch(array1, array2) {
    'use strict';
    var x, l;
    if (array1.length !== array2.length) {
        return false;
    }
    l = array1.length;
    for (x = 0; x < l; x += 1) {
        if (array1[x] !== array2[x]) {
            return false;
        }
    }
    return true;
};
atropa.arrays.subtract = function (a, fromB) {
    'use strict';
    var the = {};
    the.result = [];
    fromB.forEach(function (item) {
        the.mark = false;
        a.forEach(function (rm) {
            if (item === rm) {
                the.mark = true;
            }
        });
        if (the.mark !== true) {
            the.result.push(item);
        }
    });
    return the.result;
};
atropa.arrays.intersect = function intersect(array1, array2) {
    'use strict';
    var smallArray, largeArray, intersection = [];
    if (array1.length > array2.length) {
        largeArray = array1.splice(0);
        smallArray = array2.splice(0);
    } else {
        largeArray = array2.splice(0);
        smallArray = array1.splice(0);
    }
    smallArray.forEach(function (item) {
        var idxInLargeArray = largeArray.indexOf(item);
        if (0 <= idxInLargeArray) {
            intersection.push(largeArray.splice(idxInLargeArray, 1)[0]);
        }
    });
    return intersection;
};
atropa.arrays.getFrequency = function (arr) {
    'use strict';
    var out = arr.reduce(function (acc, curr) {
            if (acc[curr] === undefined) {
                acc[curr] = 1;
            } else {
                acc[curr] += 1;
            }
            return acc;
        }, {});
    return out;
};
atropa.arrays.getUnique = function (largeArray) {
    'use strict';
    return Object.keys(atropa.arrays.getFrequency(largeArray)).sort();
};
atropa.arrays.removeEmptyElements = function (arrayWithEmptyElements) {
    'use strict';
    return arrayWithEmptyElements.filter(function (item) {
        return !atropa.inquire.isEmptyString(item);
    });
};
atropa.arrays.reindex = function reindex(arr) {
    'use strict';
    var idx, out;
    out = [];
    for (idx in arr) {
        if (arr.hasOwnProperty(idx)) {
            out.push(arr[idx]);
        }
    }
    return out;
};
atropa.arrays.sortNumerically = function sortNumerically(arr) {
    'use strict';
    return arr.sort(function (a, b) {
        return a - b;
    });
};
atropa.arrays.sortAlphabetically = function sortAlphabetically(arr) {
    'use strict';
    throw new Error('String.prototype.localeCompare is not standardized');
};
atropa.arrays.deleteElement = function (arr, index) {
    'use strict';
    delete arr[index];
    return atropa.arrays.reindex(arr);
};
atropa.SerialActor = function (actorName, actorFunction) {
    'use strict';
    var that, dummyActor;
    that = this;
    dummyActor = function () {
        console.log('actorFunction would execute');
        console.log('freeing Serial Actor in 10000 ms');
        setTimeout(function () {
            that.free();
        }, 10000);
    };
    this.name = atropa.setAsOptionalArg('SerialActor', actorName);
    this.interval = 100;
    this.intervalId = undefined;
    this.blocked = false;
    this.timeouts = [];
    this.blockTimeoutValue = 60000;
    this.actorFunction = atropa.setAsOptionalArg(dummyActor, actorFunction);
    this.action = function () {
        if (false === that.blocked) {
            that.block();
            setTimeout(function () {
                that.actorFunction();
            }, 10);
        } else {
            console.log(that.name + ' sleeping for ' + that.interval + ' ms');
        }
    };
};
atropa.SerialActor.prototype.block = function () {
    'use strict';
    var that = this;
    console.log(this.name + ' block');
    this.blocked = true;
    this.timeouts.push(setTimeout(function () {
        that.blockTimeout();
    }, that.blockTimeoutValue));
    return this.blocked;
};
atropa.SerialActor.prototype.blockTimeout = function () {
    'use strict';
    console.log(this.name + ' block timeout');
    return this.free();
};
atropa.SerialActor.prototype.free = function () {
    'use strict';
    console.log(this.name + ' free');
    this.blocked = false;
    clearTimeout(this.timeouts.shift());
    return this.blocked;
};
atropa.SerialActor.prototype.start = function (interval) {
    'use strict';
    var that = this;
    this.interval = atropa.setAsOptionalArg(this.interval, interval);
    if (this.intervalId !== undefined) {
        this.stop();
    }
    this.intervalId = setInterval(that.action, that.interval);
    console.log(this.name + ' started');
    return this.intervalId;
};
atropa.SerialActor.prototype.changeInterval = function (interval) {
    'use strict';
    console.log(this.name + ' changing interval');
    return this.start(interval);
};
atropa.SerialActor.prototype.stop = function () {
    'use strict';
    clearInterval(this.intervalId);
    this.intervalId = undefined;
    console.log(this.name + ' stopped');
};
atropa.requires('Babbler', function () {
    'use strict';
    var supported = true;
    [
        atropa.random.integer,
        atropa.string.ucFirst,
        atropa.random.string
    ].forEach(function (prerequisite) {
        if (prerequisite === undefined) {
            supported = false;
        }
    });
    return supported;
}, 'atropa.Babbler class is not supported in this environment');
atropa.Babbler = function Babbler(wrdCount) {
    'use strict';
    var my = this, babble = '', wordCount = 0;
    this.setWordCount = function (wrdCount) {
        if (typeof wrdCount !== 'number') {
            wordCount = 250;
        } else {
            wordCount = wrdCount;
        }
        return wordCount;
    };
    this.resetWordCount = function resetWordCount(wordCount) {
        my.setWordCount(wordCount);
        return wordCount;
    };
    this.getWordCount = function getWordCount() {
        return wordCount;
    };
    this.generateWord = function generateWord(stringMin, stringMax) {
        var wordLength, word;
        wordLength = atropa.random.integer(stringMin, stringMax);
        word = atropa.random.string(wordLength, 'lower');
        wordCount--;
        return word;
    };
    this.punctuate = function punctuate() {
        var punctuation;
        punctuation = atropa.random.string(1, 'punctuation');
        return punctuation;
    };
    this.generateSentence = function generateSentence(sentenceMin, sentenceMax) {
        var word, sentenceLength, sentence;
        sentenceLength = atropa.random.integer(sentenceMin, sentenceMax);
        sentence = '';
        if (sentenceLength > wordCount) {
            sentenceLength = wordCount;
        }
        for (sentenceLength; sentenceLength > 0; sentenceLength--) {
            if (wordCount > 0) {
                word = my.generateWord(4, 12);
                sentence += ' ' + word;
            } else {
                sentenceLength = 0;
            }
        }
        sentence += my.punctuate();
        return atropa.string.ucFirst(sentence.trim());
    };
    this.setBabble = function setBabble(babbleString) {
        if (typeof babbleString === 'string') {
            babble = babbleString;
        } else {
            my.resetBabble();
        }
        return babble;
    };
    this.resetBabble = function resetBabble() {
        babble = '';
        return babble;
    };
    this.getBabble = function getBabble() {
        return babble;
    };
    this.generateBabble = function generateBabble(wordsCt) {
        my.resetBabble();
        my.resetWordCount(wordsCt);
        for (wordCount; wordCount > 0; babble += ' ') {
            my.setBabble(babble + my.generateSentence(5, 20));
        }
        return babble;
    };
    atropa.supportCheck('Babbler');
    this.resetWordCount(wrdCount);
};
atropa.requires('CookieMonster', function () {
    'use strict';
    var supported = true;
    [document.cookie].forEach(function (prerequisite) {
        if (prerequisite === undefined) {
            supported = false;
        }
    });
    return supported;
}, 'atropa.CookieMonster class is not supported in this environment');
atropa.CookieMonster = function CookieMonster() {
    'use strict';
    var currentCookies, getCookieCallback;
    currentCookies = [];
    this.cookie2obj = function cookie2obj(cookie) {
        var cookieObj = {};
        if (!cookie) {
            return false;
        }
        cookieObj.key = cookie.substr(0, cookie.indexOf('=')).trim();
        cookieObj.val = cookie.substr(cookie.indexOf('=') + 1);
        if (cookieObj.val.substr(-1) === ';') {
            cookieObj.val = cookieObj.val.substr(0, cookieObj.val.length - 1);
        }
        return cookieObj;
    };
    this.bakeCookie = function bakeCookie(cookieObj) {
        var cookie = '', key, val;
        key = cookieObj.key;
        val = cookieObj.val;
        cookie = key + '=' + val + ';';
        return cookie;
    };
    this.inspectCookies = function inspectCookies(callback, args) {
        var testCookie, cookies, jar = [];
        cookies = this.getCookies();
        while (cookies.length > 0) {
            testCookie = cookies.shift();
            if (callback(testCookie, args) === true) {
                jar.push(testCookie);
            }
        }
        return jar;
    };
    getCookieCallback = function getCookieCallback(testCookie, args) {
        var out;
        if (testCookie.key === args) {
            out = true;
        } else {
            out = false;
        }
        return out;
    };
    this.getCookie = function getCookie(whichKey) {
        var result = this.inspectCookies(getCookieCallback, whichKey.trim());
        return result[0] || false;
    };
    this.getCookies = function getCookies() {
        var n, l, cookieArray, cookieObj;
        currentCookies = [];
        cookieArray = document.cookie.split(';');
        for (n = 0, l = cookieArray.length; n < l; n++) {
            cookieObj = false;
            if (cookieArray[n]) {
                cookieObj = this.cookie2obj(cookieArray[n]);
                if (cookieObj) {
                    currentCookies.push(cookieObj);
                }
            }
        }
        return currentCookies;
    };
    this.deleteCookie = function deleteCookie(whichKey) {
        var cookieObj = {};
        cookieObj.key = whichKey;
        cookieObj.val = ';expires=Thu, 2 Aug 2001 20:47:11 UTC';
        document.cookie = this.bakeCookie(cookieObj);
    };
    this.deleteCookieObj = function deleteCookieObj(cookieObj) {
        this.deleteCookie(cookieObj.key);
    };
    this.setCookie = function setCookie(whichKey, setTo) {
        var newCookie = {};
        newCookie.key = whichKey;
        newCookie.val = setTo;
        document.cookie = this.bakeCookie(newCookie);
    };
    this.setCookieObj = function setCookieObj(cookieObj) {
        return this.setCookie(cookieObj.key, cookieObj.val);
    };
    atropa.supportCheck('CookieMonster');
};
atropa.requires('CreateHtmlDocumentsFromXmlhttp', function () {
    'use strict';
    var supported = true;
    [
        atropa.Requester,
        atropa.HTMLParser
    ].forEach(function (prerequisite) {
        if (prerequisite === undefined) {
            supported = false;
        }
    });
    return supported;
}, 'atropa.CreateHtmlDocumentsFromXmlhttp class is not supported in this environment');
atropa.CreateHtmlDocumentsFromXmlhttp = function CreateHtmlDocumentsFromXmlhttp() {
    'use strict';
    var requester, htmldocument, that;
    that = this;
    this.documentQueue = [];
    this.newDocument = function newDocument(method, url, messageBody, callback) {
        var cb;
        cb = function (boolStatus, responseObject) {
            var result = false;
            if (boolStatus === true) {
                if (false !== htmldocument.loadString(responseObject.responseText)) {
                    result = htmldocument.doc;
                    that.documentQueue.push(result);
                }
            } else {
                result = boolStatus;
            }
            callback(result);
        };
        requester.makeRequest(method, url, messageBody, cb);
    };
    function init() {
        try {
            atropa.supportCheck('CreateHtmlDocumentsFromXmlhttp');
            requester = new atropa.Requester();
            htmldocument = new atropa.HTMLParser();
        } catch (e) {
            atropa.data.CreateHtmlDocumentsFromXmlhttp.support = 'unsupported';
            throw new Error(atropa.data.CreateHtmlDocumentsFromXmlhttp.error);
        }
    }
    init();
};
atropa.InvalidArgumentTypesError = function InvalidArgumentTypesError(message) {
    'use strict';
    this.name = 'atropa.InvalidArgumentTypesError';
    this.message = message || 'InvalidArgumentTypesError';
};
atropa.InvalidArgumentTypesError.prototype = new Error();
atropa.InvalidArgumentTypesError.prototype.constructor = atropa.InvalidArgumentTypesError;
atropa.requires('HTMLParser', function () {
    'use strict';
    var supported = true;
    [
        document.implementation.createDocumentType,
        document.implementation.createDocument
    ].forEach(function (prerequisite) {
        if (prerequisite === undefined) {
            supported = false;
        }
    });
    return supported;
}, 'atropa.HTMLParser class is not supported in this environment');
atropa.HTMLParser = function HTMLParser() {
    'use strict';
    var my = this;
    this.doc = {};
    this.newDocument = function () {
        var dt;
        dt = document.implementation.createDocumentType('html', '-//W3C//DTD HTML 4.01 Transitional//EN', 'http://www.w3.org/TR/html4/loose.dtd');
        my.doc = document.implementation.createDocument('', '', dt);
        if (my.doc.nodeType !== 9) {
            atropa.data.HTMLParser.support = 'unsupported';
            throw new Error(atropa.data.HTMLParser.error + 'the document nodeType returned an unexpected value');
        }
        return my.doc;
    };
    this.loadString = function (htmlstring) {
        if (!htmlstring) {
            return false;
        }
        try {
            my.newDocument();
            my.doc.appendChild(my.doc.createElement('html'));
            my.doc.documentElement.innerHTML = htmlstring;
        } catch (e) {
            atropa.data.HTMLParser.support = 'unsupported';
            throw new Error(atropa.data.HTMLParser.error + 'atropa.HTMLParser can not load ' + 'the hidden document from string because: ' + e);
        }
        return my.doc;
    };
    function init() {
        var eqTest;
        atropa.supportCheck('HTMLParser');
        try {
            eqTest = my.loadString('<head></head><body><p>test</p></body>').body.textContent;
        } catch (e) {
            atropa.data.HTMLParser.support = 'unsupported';
            throw new Error(atropa.data.HTMLParser.error + e);
        }
        if ('test' !== eqTest) {
            atropa.data.HTMLParser.support = 'unsupported';
            throw new Error(atropa.data.HTMLParser.error);
        }
        my.newDocument();
    }
    init();
};
atropa.requires('inject', function () {
    'use strict';
    if (document.createElement === undefined) {
        return false;
    }
    return true;
}, 'The atropa.inject class requires the window object present in web ' + 'browsers in order to be useful. atropa.inject is not supported in ' + 'this environment');
atropa.inject = {};
atropa.inject.element = function (elementType, docref, parentNod, attributes, onloadHandler, callback) {
    'use strict';
    atropa.supportCheck('inject');
    var el, x;
    docref = atropa.setAsOptionalArg(document, docref);
    parentNod = atropa.setAsOptionalArg(docref.body, parentNod);
    attributes = atropa.setAsOptionalArg({}, attributes);
    onloadHandler = atropa.setAsOptionalArg(atropa.nop, onloadHandler);
    callback = atropa.setAsOptionalArg(atropa.nop, callback);
    el = docref.createElement(elementType);
    for (x in attributes) {
        if (attributes.hasOwnProperty(x)) {
            el.setAttribute(x, attributes[x]);
        }
    }
    el.addEventListener('load', onloadHandler, true);
    callback(el);
    parentNod.appendChild(el);
    return el;
};
atropa.inject.hiddenFrame = function (id, srcURL, docref, onloadHandler, parentNod, callback) {
    'use strict';
    atropa.supportCheck('inject');
    return atropa.inject.element('iframe', docref, parentNod, {
        'id': id,
        'src': srcURL,
        'width': '0px',
        'height': '0px',
        'border': '0px'
    }, onloadHandler, callback);
};
atropa.inject.script = function (id, srcURL, docref, callback) {
    'use strict';
    atropa.supportCheck('inject');
    var attributes, elementType, parentNod = null, onloadHandler, el;
    attributes = {
        'id': id,
        'type': 'text/javascript',
        'src': srcURL
    };
    elementType = 'script';
    onloadHandler = callback;
    el = atropa.inject.element(elementType, docref, parentNod, attributes, onloadHandler);
    return el;
};
atropa.inquire = {};
atropa.inquire.isNull = function (x) {
    'use strict';
    return x === null;
};
atropa.inquire.isObject = function (x) {
    'use strict';
    return typeof x === 'object';
};
atropa.inquire.isObjectNotNull = function (x) {
    'use strict';
    return atropa.inquire.isObject(x) && !atropa.inquire.isNull(x);
};
atropa.inquire.hasProperty = function (obj, prop) {
    'use strict';
    if (atropa.inquire.isObjectNotNull(obj)) {
        return prop in obj;
    }
    return false;
};
atropa.inquire.isEmptyString = function (str) {
    'use strict';
    var out = false;
    if ('' === str) {
        out = true;
    }
    return out;
};
atropa.objects = {};
atropa.objects.convertObjectToArray = function convertObjectToArray(obj) {
    'use strict';
    var prop, out = [];
    for (prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            out.push([
                prop,
                obj[prop]
            ]);
        }
    }
    return out;
};
atropa.objects.sort = function sort(obj, sortFn) {
    'use strict';
    return atropa.objects.convertObjectToArray(obj).sort(sortFn);
};
atropa.objects.sortValues = function sortValues(obj, sortFn) {
    'use strict';
    var valSort = function (a, b) {
        return sortFn(a[1], b[1]);
    };
    return atropa.objects.sort(obj, valSort);
};
atropa.objects.sortProperties = function sortValues(obj, sortFn) {
    'use strict';
    var propSort = function (a, b) {
        return sortFn(a[0], b[0]);
    };
    return atropa.objects.sort(obj, propSort);
};
atropa.objects.sortValuesNumerically = function sortValuesNumerically(obj) {
    'use strict';
    function sortFn(a, b) {
        return a - b;
    }
    return atropa.objects.sortValues(obj, sortFn);
};
atropa.objects.sortValuesAlphabetically = function sortValuesAlphabetically(obj) {
    'use strict';
    function sortFn(a, b) {
        return a.localeCompare(b);
    }
    return atropa.objects.sortValues(obj, sortFn);
};
atropa.objects.sortPropertiesNumerically = function sortPropertiesNumerically(obj) {
    'use strict';
    function sortFn(a, b) {
        return a - b;
    }
    return atropa.objects.sortProperties(obj, sortFn);
};
atropa.objects.sortPropertiesAlphabetically = function sortPropertiesAlphabetically(obj) {
    'use strict';
    function sortFn(a, b) {
        return a.localeCompare(b);
    }
    return atropa.objects.sortProperties(obj, sortFn);
};
atropa.random = {};
atropa.random.string = function randomString(stringLength, characterClass) {
    'use strict';
    var numeric, vowel, consonant, lower, caps, alpha, alphanumeric, punctuation, chars, string_length, randomstring, i, character;
    numeric = '0123456789';
    vowel = 'aeiouy';
    consonant = 'bcdfghjklmnpqrstvwxz';
    lower = vowel + consonant;
    caps = lower.toUpperCase();
    alpha = caps + lower;
    alphanumeric = numeric + caps + lower;
    punctuation = '.?!';
    randomstring = '';
    switch (characterClass) {
    case 'numeric':
        chars = numeric;
        break;
    case 'caps':
        chars = caps;
        break;
    case 'lower':
        chars = lower;
        break;
    case 'alpha':
        chars = alpha;
        break;
    case 'alphanumeric':
        chars = alphanumeric;
        break;
    case 'punctuation':
        chars = punctuation;
        break;
    case 'vowel':
        chars = vowel;
        break;
    case 'consonant':
        chars = consonant;
        break;
    default:
        chars = alphanumeric;
        break;
    }
    if (stringLength === undefined) {
        string_length = 4;
    } else {
        string_length = stringLength;
    }
    for (i = 0; i < string_length; i++) {
        character = Math.floor(Math.random() * chars.length);
        randomstring += chars[character];
    }
    return randomstring;
};
atropa.random.integer = function randomInteger(min, max) {
    'use strict';
    return Math.floor(Math.random() * (max - min + 1) + min);
};
atropa.random.getPropertyName = function (obj) {
    'use strict';
    var arr;
    arr = Object.keys(obj);
    return arr[atropa.random.getArrayKey(arr)];
};
atropa.random.getArrayKey = function (arr) {
    'use strict';
    return Math.floor(Math.random() * arr.length);
};
atropa.random.getArrayValue = function (arr) {
    'use strict';
    return arr[atropa.random.getArrayKey(arr)];
};
atropa.random.pullArrayElement = function (arr) {
    'use strict';
    var k, d;
    k = atropa.random.getArrayKey(arr);
    d = arr[k];
    arr.splice(k, 1);
    return d;
};
atropa.random.pullProperty = function (obj) {
    'use strict';
    var pName, objData;
    pName = atropa.random.getPropertyName(obj);
    objData = obj[pName];
    delete obj[pName];
    return objData;
};
atropa.regex = {};
atropa.regex.patterns = {
    repeatedWords: /(\b.{3,}\b)\s*(\1)/g,
    paragraphBreaks: /(\r\n\r\n|\n\n|\r\r)/g,
    lineBreaks: /(\r\n|\r|\n)/g
};
atropa.regex.appendPrefixesAndSuffixes = function (word, threshold) {
    'use strict';
    var prefixes, suffixes;
    prefixes = '(pre|un|re)?';
    suffixes = '(ification|' + 'tionally|' + 'ication|' + 'ified|istic|iness|' + 'fare|tion|ance|ence|less|ally|able|ness|ized|ised|' + 'ous|ify|ing|ity|ful|ant|ate|est|ism|izm|ist|' + 'ic|al|ed|er|et|ly|rs|in|' + 'y|s|r|d)?';
    threshold = threshold === undefined ? 3 : threshold;
    if (word.length > threshold) {
        word = '\\b' + prefixes + word + suffixes + '\\b';
    } else {
        word = '\\b()' + word + '()\\b';
    }
    return word;
};
atropa.requires('removeNodeByReference', function () {
    'use strict';
    if (document === undefined) {
        return false;
    }
    return true;
}, 'atropa.removeNodeByReference requires the window object present in web ' + 'browsers in order to be useful. This function is not supported in ' + 'this environment');
atropa.removeNodeByReference = function (elementReference) {
    'use strict';
    atropa.supportCheck('removeNodeByReference');
    if (elementReference !== undefined) {
        elementReference.parentNode.removeChild(elementReference);
    }
};
(function () {
    'use strict';
    atropa.requires('Requester', function () {
        var supported = true;
        [
            atropa.ArgsInfo,
            XMLHttpRequest
        ].forEach(function (prerequisite) {
            if (prerequisite === undefined) {
                supported = false;
            }
        });
        return supported;
    }, 'atropa.Requester class is not supported in this environment');
}());
atropa.Requester = function Requester() {
    'use strict';
    var expArgTypes, checkRequest, request;
    expArgTypes = {};
    expArgTypes.requestWithMessage = [
        'string',
        'string',
        'string',
        'function'
    ];
    expArgTypes.requestNullMessage = [
        'string',
        'string',
        'object',
        'function'
    ];
    checkRequest = function (args) {
        var checker;
        checker = new atropa.ArgsInfo();
        checker.setExpectedArgTypes(expArgTypes);
        return checker.checkArgTypes(args);
    };
    this.requestHeaders = {};
    this.timeout = 30000;
    request = new XMLHttpRequest();
    request.aborted = false;
    request.abort = function () {
        request.aborted = true;
        XMLHttpRequest.prototype.abort.call(this);
    };
    this.makeRequest = function (method, url, messageBody, callback) {
        var hdr;
        try {
            checkRequest(arguments);
        } catch (e) {
            throw new Error('atropa.Requester.makeRequest unexpected ' + 'argument type');
        }
        request.aborted = false;
        request.open(method, url, true);
        for (hdr in this.requestHeaders) {
            if (this.requestHeaders.hasOwnProperty(hdr)) {
                request.setRequestHeader(hdr, this.requestHeaders[hdr]);
            }
        }
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    callback(true, request);
                } else {
                    callback(false, request);
                }
            }
        };
        request.send(messageBody);
        setTimeout(function () {
            if (request.aborted === false) {
                request.abort();
            }
        }, this.timeout);
    };
    atropa.supportCheck('Requester');
};
atropa.setAsOptionalArg = function (defaultVal, optionalArg) {
    'use strict';
    if (optionalArg === undefined || optionalArg === null) {
        optionalArg = defaultVal;
    }
    return optionalArg;
};
atropa.string = {};
atropa.string.removeRepeatedWord = function removeRepeatedWord(string) {
    'use strict';
    return string.replace(atropa.regex.patterns.repeatedWords, '$1');
};
atropa.string.lineBreaksToParagraphTags = function lineBreaksToParagraphTags(string) {
    'use strict';
    var out = string.replace(atropa.regex.patterns.paragraphBreaks, '</p><p>');
    out = '<p>' + out.trim() + '</p>';
    out = out.replace(/\s+<\/(p|br)>/g, '</$1>');
    return out;
};
atropa.string.lineBreaksToBreakTags = function lineBreaksToBreakTags(string) {
    'use strict';
    return string.replace(atropa.regex.patterns.lineBreaks, '<br>');
};
atropa.string.normalizeEol = function normalizeEol(string) {
    'use strict';
    return string.replace(atropa.regex.patterns.lineBreaks, '\n');
};
atropa.string.ucFirst = function ucFirst(string) {
    'use strict';
    string = string.charAt(0).toUpperCase() + string.slice(1);
    return string;
};
atropa.string.camelize = function camelize(str) {
    'use strict';
    var arr, out;
    arr = str.split(' ');
    out = arr.shift();
    arr = arr.map(function (item) {
        return atropa.string.ucFirst(item);
    });
    out += arr.join('');
    return out;
};
atropa.string.countWords = function countWords(someText) {
    'use strict';
    var wordCount, re, len = 0;
    if (someText !== undefined && someText !== null) {
        someText = someText.trim();
        if (someText !== '') {
            wordCount = 0;
            re = /\s+/gi;
            wordCount = someText.split(re);
            len = wordCount.length;
        }
    }
    return len;
};
atropa.string.convertEol = function convertEOL(text, newEOL) {
    'use strict';
    return text.replace(atropa.regex.patterns.lineBreaks, newEOL);
};
atropa.string.offsetWhiteSpace = function offsetWhiteSpace(text, offset) {
    'use strict';
    var regx;
    regx = new RegExp('^ {' + offset + '}');
    text = text.replace(regx, '');
    return text;
};
atropa.string.normalizeWhiteSpacePrefix = function normalizeWhiteSpacePrefix(text) {
    'use strict';
    var prefix = text.match(/^\s*/);
    if (prefix) {
        prefix = prefix[0];
        prefix = prefix.replace(/\t/g, '    ');
        text = text.replace(/^\s*/, prefix);
    }
    return text;
};
atropa.string.normalizeWhiteSpace = function normalizeWhiteSpace(text) {
    'use strict';
    text = text.replace(/\t/g, '    ');
    return text;
};
atropa.string.getOffset = function getOffset(text) {
    'use strict';
    var offset = 0, leadingChar = text.charAt(0);
    if (leadingChar === ' ' || leadingChar === '\t') {
        while (text.charAt(offset) === leadingChar && offset < text.length) {
            offset++;
        }
    }
    return offset;
};
atropa.string.getWords = function (text) {
    'use strict';
    var out = [];
    function invalidChars(element) {
        var matched = /^[\-'’`]+$/.test(element);
        return !matched;
    }
    out = atropa.arrays.removeEmptyElements(text.split(/[^A-Za-z\-'’`]+/gi));
    out = out.filter(invalidChars);
    return out;
};
atropa.string.escapeCdata = function escapeCdata(text) {
    'use strict';
    return String(text).replace(/\]\]>/g, ']]]]><![CDATA[>');
};
(function () {
    'use strict';
    atropa.requires('TextAnalyzer', function () {
        var supported = true;
        [
            atropa.string,
            atropa.arrays,
            atropa.setAsOptionalArg
        ].forEach(function (prerequisite) {
            if (prerequisite === undefined) {
                supported = false;
            }
        });
        return supported;
    }, 'atropa.TextAnalyzer class is not supported in this environment');
}());
atropa.TextAnalyzer = function TextAnalyzer(text) {
    'use strict';
    var that = this;
    var construct;
    this.text = String(atropa.setAsOptionalArg('', text));
    this.wordCount = 0;
    this.words = [];
    construct = function () {
        atropa.supportCheck('TextAnalyzer');
        that.text = atropa.string.convertEol(that.text, '\n');
        that.wordCount = atropa.string.countWords(that.text);
        that.words = atropa.string.getWords(that.text);
    };
    construct();
    return this;
};
atropa.TextAnalyzer.prototype.getIndex = function () {
    'use strict';
    this.words = atropa.arrays.reindex(this.words);
    return atropa.arrays.getUnique(this.words);
};
atropa.TextAnalyzer.prototype.getWordFrequency = function () {
    'use strict';
    this.words = atropa.arrays.reindex(this.words);
    return atropa.arrays.getFrequency(this.words);
};
atropa.TextAnalyzer.prototype.getPhraseFrequency = function getPhraseFrequency(phraseLength) {
    'use strict';
    phraseLength = atropa.setAsOptionalArg(2, phraseLength);
    if (2 > phraseLength) {
        phraseLength = 2;
    }
    var counter = 0, prop, out = [];
    this.words = atropa.arrays.reindex(this.words);
    this.words.map(function (element, index, arr) {
        counter = 1;
        if (arr[index + phraseLength - 1] !== undefined) {
            prop = String(element + ' ').toLowerCase();
            for (counter; counter !== phraseLength; counter++) {
                prop += String(arr[index + counter] + ' ').toLowerCase();
            }
            out.push(prop.trim());
        }
    });
    out = atropa.arrays.getFrequency(out);
    return out;
};
atropa.url = {};
atropa.url.getFilename = function (url) {
    'use strict';
    var filename;
    try {
        filename = String(url).replace(/.*:\/\/[^\/]+/, '').replace(/[#|?].*$/, '').match(/[^\/]+$/)[0];
    } catch (e) {
        filename = '';
    }
    if (url === filename) {
        filename = '';
    }
    return filename;
};
atropa.waitFor = {};
atropa.waitFor.test = function test(testFn, onSuccessCallback, onMaxPollCallback, pollInterval, maxPoll) {
    'use strict';
    pollInterval = atropa.setAsOptionalArg(200, pollInterval);
    maxPoll = atropa.setAsOptionalArg(50, maxPoll);
    onMaxPollCallback = atropa.setAsOptionalArg(atropa.nop, onMaxPollCallback);
    onSuccessCallback = atropa.setAsOptionalArg(atropa.nop, onSuccessCallback);
    var myInt;
    var myCounter = 0;
    function waitForTestRecursor() {
        myCounter++;
        if (testFn()) {
            clearInterval(myInt);
            onSuccessCallback();
        }
        if (myCounter === maxPoll) {
            clearInterval(myInt);
            onMaxPollCallback();
        }
    }
    myInt = setInterval(waitForTestRecursor, pollInterval);
};
atropa.waitFor.element = function (testFn, onSuccessCallback, onMaxPollCallback, pollInterval, maxPoll) {
    'use strict';
    function elementTest() {
        return atropa.inquire.hasProperty(testFn(), 'tagName');
    }
    atropa.waitFor.test(elementTest, onSuccessCallback, onMaxPollCallback, pollInterval, maxPoll);
};
(function () {
    'use strict';
    atropa.requires('wtf', function () {
        var supported = true;
        [
            atropa.regex,
            atropa.string.countWords,
            atropa.setAsOptionalArg
        ].forEach(function (prerequisite) {
            if (prerequisite === undefined) {
                supported = false;
            }
        });
        return supported;
    }, 'atropa.wtf class is not supported in this environment');
}());
(function () {
    'use strict';
    atropa.requires('wtfHtmlElement', function () {
        var supported = true;
        [window].forEach(function (prerequisite) {
            if (prerequisite === undefined) {
                supported = false;
            }
        });
        return supported;
    }, 'atropa.wtf class is not supported in this environment');
}());
atropa.wtf = {};
atropa.wtf.dictionary = {
    'novelty quickly wears off': 'dumb shit gits old fast',
    'the way it is': 'how it be',
    'put up with': 'manhandle',
    'yet': 'immediately',
    'lose': 'shake',
    'for no reason': 'maiacally',
    'given a choice': 'extorted',
    'not strong enough': 'ain\'t got the nuts',
    'now at an end': 'brand spankin new',
    'be together': 'mash up',
    'apocalypse': 'party time',
    'nothing is assured': 'we live to deliver',
    'to no avail': 'for great good',
    'too good to be true': 'fucking fantastic',
    'growing apart': 'fucking other people',
    'rest in peace': 'party like it\'s 1999',
    'back stab': 'rump shake',
    'back stabb': 'rump shake',
    'look into their eyes': 'give them AIDS',
    'look into her eyes': 'give her AIDS',
    'look into his eyes': 'give him AIDS',
    'can\'t live without': 'touch myself about',
    'can\'t be without': 'touch myself about',
    'could never be without': 'can\'t work anal beads without',
    'no matter': 'irregardless of',
    'will be there': 'stick like shit',
    'will always be there': 'stick like wet shit',
    'holding them close to': 'handcuffing them to',
    'by your side': 'on your ass',
    'by my side': 'on my ass',
    'by his side': 'on his ass',
    'by her side': 'on her ass',
    'leave your side': 'get off your ass',
    'leave my side': 'get off my ass',
    'leave his side': 'get off his ass',
    'leave her side': 'get off her ass',
    'doesn\'t happen over': 'cartwheels straight across',
    'means many things': 'is best described with lies',
    'laying in bed': 'taking a shit',
    'promise': 'lie',
    'liar': 'fibber',
    'lie': 'fib',
    'lies': 'fibs',
    'what\'s the point': 'the fucks this mean',
    'it must be true': 'for real \'n\' shit',
    'what people say': 'muthaphukkas be talkin',
    'etched': 'ground',
    'don\'t have a clue': 'got shit twisted',
    'viscious cycle': 'clusterfuck',
    'don\'t need': 'could give a fuck about',
    'raven': 'pigeon',
    'to get away': 'to fucking run',
    'to a better': 'for some glittered',
    'beautiful face': 'enormous tits',
    'might as well': 'oh fuck I oughtta',
    'the first moment': 'straightaway',
    'as well': 'also',
    'so good': 'neato',
    'could do anything': 'is fucking insane',
    'set the mood': 'whip it out',
    'baby if': 'look bitch,',
    'through your hair': 'upside your head',
    'entered the house of': 'got up in the barn for',
    'always love you the same': 'always love you like my other suckers',
    'kissing other': 'going down on',
    'never thought you would do that': 'got turned out like a dumb fuck',
    'laying on the floor': 'begging for it',
    'first laid eyes on': 'first tried groping',
    'most people can only': 'most freaks and dope fiends',
    'you were the one': 'you were my target',
    'standing out from the crowd': 'wobbling like an elephant on a bicycle',
    'stood out from the crowd': 'jiggled like a jello Santa',
    'stand out from the crowd': 'look like a jackass',
    'stands out from the crowd': 'smells like old dick',
    'i\'ve never felt this way': 'i\'ve done this',
    'with every fiber': 'from pithy pits',
    'wander': 'stumble',
    'haunt': 'stalk',
    'mask': 'trashbag',
    'demonic angel': 'ass pirate',
    'angelic demon': 'ass pirate',
    'cunning': 'desperate',
    'dangerous': 'cock catching',
    'demi-god': 'punk bitch',
    'demigod': 'punk bitch',
    'mortal': 'queer',
    'immortal': 'whiny',
    'betrayal': 'game',
    'betray': 'screw',
    'gave up on': 'don\'t give a fuck about',
    'give up on': 'won\'t give a fuck about',
    'given up on': 'don\'t give a fuck about',
    'giving up on': 'ain\'t givin a fuck about',
    'coffin': 'tobogan',
    'beautiful': 'gaudy',
    'the best': 'the baddest',
    'selfish': 'thieving',
    'walked out': 'narrowly escaped',
    'walk out': 'narrowly escape',
    'walking out': 'narrowly escaping',
    'got in your way': 'got all up in your shit',
    'try': 'shoot',
    'the point of no return': 'the fat girls bedrooom door',
    'only wanted': 'begged for',
    'guess it doesn\'t matter': 'know this shit is pointless',
    'look back': 'lick windows',
    'path': 'sidewalk',
    'shine': 'bling',
    'in the middle of': 'all up in',
    'deep down inside': 'in the bottom of the tank',
    'piece by piece': 'one handjob at a time',
    'aura': 'stench',
    'candle': 'glowstick',
    'for her': 'to that broads',
    'for she': '\'cause the cunt',
    'for he': 'this dumb mother fucker',
    'forest': 'campground',
    'hand in hand': 'cock to jaw',
    'hand to hold': 'nuts to grip',
    'girl meets boy': 'horny kids hook up',
    'boy meets girl': 'horny kids hook up',
    'sunny': 'sweltering',
    'so nervous': 'so fucking drunk',
    'kiss': 'slap',
    'fingertips': 'chicken nuggets',
    'tell you i\'m fine': 'screm I\'M FUCKIN OK',
    'write': 'scrawl',
    'written': 'scrawled',
    'wrote': 'scrawled',
    'first of all': 'mm-kay',
    'bring forth': 'whip out',
    'into the light': 'on to the light',
    'the only one': 'fucking stupid',
    'to the light': 'out in public',
    'talk': 'cuss',
    'full of life': 'full of shit',
    'can\'t find the words to say': 'could blurt out some dumb shit',
    'consume': 'suck',
    'consuming': 'sucking',
    'pillow': 'stone',
    'advice': 'bullshit',
    'universe': 'toilet bowl',
    'elder': 'old folk',
    'magick': 'delusion',
    'magic': 'hope',
    'arcane': 'foolish',
    'speak of': 'talk about',
    'shall': 'should-will',
    'obtain': 'get',
    'battle': 'squabble',
    'midnight': 'daybreak',
    'sorrow': 'whimper',
    'crimson': 'azure',
    'black': 'yellow',
    'won\'t make it through': 'could shimmy past',
    'night': 'bedtime',
    'day': 'morning',
    'fragile': 'sturdy',
    'crack': 'mend',
    'solitude': 'ambiance',
    'torment': 'tickle',
    'incantation': 'much yammering',
    'hopeless': 'pitiful',
    'depressing': 'inebriating',
    'depressed': 'drunk',
    'depression': 'so much booze',
    'saddened': 'made flaccid',
    'sadness': 'impotence',
    'neverending': 'never ending',
    'never ending': 'relentless',
    'never going': 'fucked for trying',
    'change one thing': 'fuck some\'n up',
    'never end': 'drag on',
    'will not heal': 'festers',
    'outward appearance': 'facade',
    'emo': 'closet homo',
    'blackened walls': 'filthy rooms',
    'farewell': 'adios',
    'meet again': 'have another go-round',
    'sadd': 'flaccid',
    'sad': 'impotent',
    'amidst': 'all up in',
    'midst': 'pants',
    'knowledge': 'trivia',
    'known': 'got',
    'know': 'get',
    'knew': 'got',
    'passionate': 'delirious',
    'passion': 'delirium',
    'o\'': 'uh',
    'o': 'uh',
    'fang': 'denture',
    'curse': 'stain',
    'love': 'confuse',
    'vampiric': 'pedophilic',
    'vampyre': 'pedophyle',
    'vampire': 'pedophile',
    'problem': 'useless concern',
    'feel': 'fondle',
    'woe': 'chlamydia',
    'empty': 'bloated',
    'hatred': 'odium',
    'hate': 'dislike',
    'scarred': 'striated',
    'scars': 'striae',
    'scare': 'tickle',
    'scary': 'tickly',
    'scar': 'stria',
    'wound': 'ouchie',
    'slit': 'crevice',
    'slice': 'pet',
    'twas': 'it was',
    'big brother': 'my paranoia',
    'eternity': 'awhile',
    'eternally': 'for a bit',
    'eternal': 'imagined',
    'prophet': 'insomniac',
    'prophecies': 'wives tales',
    'prophecy': 'wives tale',
    'soldier': 'maniac',
    'militia': 'gang',
    'military': 'gangster',
    'militant': 'maniacal',
    'goddess': 'Kylee Strutt',
    'higher power': 'crusty sock',
    'dark': 'effervescent',
    'ancient': 'elderly',
    'quest': 'stroll',
    'heartbeat': 'cock beat',
    'heart': 'cock',
    'blood': 'grease',
    'bleed': 'whine',
    'cut': 'mutilate',
    'slash': 'mutilate',
    'moonlight': 'moonshine',
    'moon': 'night light',
    'steel': 'latex',
    'knife': 'dildo',
    'razorblade': 'butt plug',
    'razor': 'dildo',
    'blade': 'handle',
    'pain': 'hot sex',
    'emotional': 'childish',
    'emotion': 'lubricant',
    'teardrop': 'tear drop',
    'tear': 'sperme',
    'castle': 'chateau',
    'world': 'hand towel',
    'dead': 'inert',
    'goodbye': 'peace y\'all',
    'good-bye': 'get the fuck out',
    'good bye': 'fuck off',
    'death': 'Santa',
    'pale': 'sexy',
    'drift': 'him-haw',
    'fade': 'him-haw',
    'flesh': 'twinkie',
    'corpse': 'mannequin',
    'skin': 'twinkies',
    'putrid': 'pleasant',
    'breathe': 'pause awkwardly',
    'breath': 'awkward pause',
    'stopp': 'push',
    'stop': 'push',
    'scream': 'grunt',
    'think': 'scheme',
    'spiritual': 'banana craving',
    'spirit': 'banana',
    'soul': 'banana',
    'ghost': 'imaginary friend',
    'monster': 'dislexic lover',
    'beast': 'erection',
    'demon': 'hard-on',
    'angel': 'porn star',
    'shooting star': 'swift missile',
    'star': 'missile',
    'lost': 'aroused',
    'time': 'throbbing',
    'cheek': 'rump',
    'fingers': 'sausage',
    'daydream': 'fantasize',
    'the spring': 'tube sock',
    'spring': 'tube socks',
    'illusion': 'drunken mistake',
    'loneliness': 'arousal',
    'lonely': 'horny',
    'alone': 'ecstatic',
    'lone': 'single',
    'perfect': 'fucked',
    'hidden': 'stashed',
    'mystery': 'neon sign',
    'mysteries': 'neon signs',
    'rose': 'butt hole',
    'petal': 'dingleberry',
    'different': 'awkward',
    'wrong': 'buzzing',
    'fate': 'coincidence',
    'cold': 'fuzzy',
    'hellfire': 'hell fire',
    'hell': 'my cock\'s',
    'crystal': 'bedazler',
    'rainbow': 'pizzazz',
    'rain': 'jizzum',
    'storm': 'orgy',
    'wind': 'blow',
    'breeze': 'draft',
    'brilliance': 'shinyness',
    'brilliant': 'shiny',
    'dreamland': 'obsession island',
    'dreams': 'obsessions',
    'dream': 'obsess',
    'prison': 'outhouse',
    'golden ray': 'gaudy scribble',
    'ray': 'scribble',
    'deadly': 'fertile',
    'truth': 'trivia',
    'sun': 'yellow disk',
    'cruel': 'haphazard',
    'cloud': 'balloon',
    'twinkle': 'strobe',
    'twinkling': 'strobing',
    'escape': 'snuggle',
    'understand': 'stroke my ego',
    'remember': 'mumble',
    'illumination': 'mumbo jumbo',
    'reality': 'toilet bowl',
    'bind': 'coddle',
    'bound': 'coddled',
    'torn': 'huggled',
    'died': 'made marshmallows',
    'dies': 'makes marshmallows',
    'die': 'make marshmallows',
    'dying': 'making marshmallows',
    'body': 'jiggling clump',
    'bodies': 'jiggling piles',
    'warfare': 'children laughing',
    'debutantes': 'hookers',
    'slave': 'gimp',
    'poetic': 'flatulent',
    'poetry': 'bad gas',
    'poet': 'hobo',
    'poem': 'scribble',
    'country': 'bathroom',
    'naked': 'unshaved',
    'jesus christ': 'jim bob jr',
    'christ': 'jim bob jr',
    'jesus': 'jim bob jr',
    'healer': 'fondler',
    'gods': 'jim bob sr et al.',
    'god': 'jim bob sr',
    'weapon': 'pocket pussy',
    'existence': 'whatever',
    'minion': 'horny pirate',
    'raping': 'what',
    'rape': 'what',
    'gravestone': 'mile marker',
    'grave': 'personal space',
    'infinite': 'abstract',
    'suicide': 'murder',
    'brink': 'border',
    'cried': 'came',
    'cries': 'skeets',
    'crying': 'cumming',
    'had done': 'done did',
    'cry': 'cum',
    'cryptic': 'drunken',
    'crypt': 'urinal',
    'mystic': 'transexual',
    'balanced individual': 'psycho',
    'balanced person': 'psycho',
    'balanced man': 'psycho',
    'balanced woman': 'psycho',
    'wisdom': 'bull shit',
    'wise': 'bull shitting',
    'blessed be': 'suck eggs',
    'energy': 'juice',
    'riddle': 'polka dot',
    'my lord': 'sweet palm',
    'so mote it be': 'it\'s real in my head',
    'pray': 'murmur',
    'nomad': 'drunk hobo',
    'destiny': 'taxes',
    'sword': 'dildo',
    'void': 'bucket',
    'just': 'sure',
    'vengeance': 'slap happiness',
    'avenge': 'git rowdy for',
    'venge': '-rowdy-',
    'heavens': 'skies',
    'heaven': 'sky',
    'endless': 'real long',
    'valley': 'ditch',
    'arduous': 'not easy',
    'touch': 'grope',
    'wretched': 'skeezy',
    'wretch': 'skeeze',
    'awe': 'fearful reverence',
    'ritual': 'banana dance',
    'behold': 'oogle',
    'veil': 'disguise',
    'vista': 'scene',
    'always': 'usually',
    'believe': 'buy',
    'wish': 'want',
    'fell': 'flopped',
    'fall': 'flop',
    'righteous': 'arrogant',
    'warrior': 'kitten',
    'uncaring': 'prickish',
    'care to give': 'shit to give',
    'take care of': 'decimate',
    'taking care': 'forgeting',
    'takes care': 'forgets',
    'take care': 'forget',
    'forget': 'disremember',
    'caring': 'giving a shit',
    'cared': 'gave a shit',
    'care': 'give a shit',
    'wield': 'jerk',
    'ocean': 'sewer',
    'sea': 'bath',
    'bay': 'sink',
    'twilight': 'moonshine',
    'broken': 'beaten',
    'broke': 'beat',
    'break': 'beat',
    'forever': 'so very',
    'human race': 'gerbil empire',
    'nightmare': 'tantrum',
    'suffer': 'pirouette',
    'myself': 'my muchness',
    'me': 'i',
    'my': 'i\'s ',
    'mine': 'i\'s',
    'was i': 'were i',
    'am i': 'are i',
    'im': 'i\'m',
    'i\'m': 'i are',
    'i\'ve': 'i have',
    'i\'ll': 'i will',
    'i am': 'i are',
    'yourself': 'you\'s muchness',
    'yours': 'you\'s',
    'your': 'you\'s',
    'you all': 'all you',
    'you\'ll': 'you will',
    'you\'ve': 'you has',
    'you\'re': 'you is',
    'thee': 'you',
    'thine': 'you\'s',
    'thou': 'you',
    'we': 'they',
    'us': 'them',
    'our': 'their',
    'ours': 'theirs',
    'i': 'Kevin',
    'you': 'Retards'
};
atropa.wtf.wtfify = function (target, outputHTML) {
    'use strict';
    atropa.supportCheck('wtf');
    var regexValue, replacementText, oldWord, wtfCount, wordCount, ret, word;
    if (true !== outputHTML) {
        outputHTML = false;
    }
    ret = {};
    wtfCount = 0;
    target = target.trim();
    wordCount = atropa.string.countWords(target);
    if (true === outputHTML) {
        target = target.replace(/(\. ?){2,}/gi, '<span style="color : brown ;"> [shit taco] </span>');
        target = '<p> ' + target.replace(/(\r\n|\r|\n)/g, ' <br/> ') + ' </p>';
    } else {
        target = target.replace(/(\. ?){2,}/gi, ' [shit taco] ');
    }
    replacementText = function (m, sub1, sub2) {
        wtfCount++;
        sub1 = atropa.setAsOptionalArg('', sub1);
        sub2 = atropa.setAsOptionalArg('', sub2);
        var out;
        if (true === outputHTML) {
            out = '<span style="color : red ;">' + sub1 + atropa.wtf.dictionary[word] + sub2 + '</span>';
        } else {
            out = sub1 + atropa.wtf.dictionary[word] + sub2;
        }
        return out;
    };
    for (word in atropa.wtf.dictionary) {
        if (atropa.wtf.dictionary.hasOwnProperty(word)) {
            oldWord = atropa.regex.appendPrefixesAndSuffixes(word);
            regexValue = new RegExp(oldWord, 'gi');
            target = target.replace(regexValue, replacementText);
        }
    }
    ret.wtfCount = wtfCount;
    ret.wordCount = wordCount;
    ret.score = wtfCount / wordCount;
    ret.txt = target;
    return ret;
};
atropa.wtf.htmlElement = function (elementReference) {
    'use strict';
    atropa.supportCheck('wtfHtmlElement');
    var wtfified, txt;
    elementReference.innerHTML = elementReference.innerHTML.replace(/<br>(\s+)?(\r\n|\r|\n)?/g, '\r\n');
    txt = elementReference.value || elementReference.textContent;
    wtfified = atropa.wtf.wtfify(txt, true);
    elementReference.innerHTML = '<pre style="color:black; background:white; white-space:pre-wrap;">' + wtfified.txt + '</pre>';
    return elementReference;
};
(function () {
    'use strict';
    atropa.requires('xpath', function () {
        var supported = true;
        [
            window,
            document.evaluate
        ].forEach(function (prerequisite) {
            if (prerequisite === undefined) {
                supported = false;
            }
        });
        return supported;
    }, 'atropa.xpath class is not supported in this environment');
}());
atropa.xpath = {};
atropa.xpath.processNodesByXpath = function processNodesByXpath(xpathExpression, contextNode, docref, callback) {
    'use strict';
    atropa.supportCheck('xpath');
    docref = atropa.setAsOptionalArg(document, docref);
    contextNode = atropa.setAsOptionalArg(docref, contextNode);
    var nodesSnapshot, nsl, i, nsi;
    nodesSnapshot = docref.evaluate(xpathExpression, contextNode, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    nsl = nodesSnapshot.snapshotLength;
    for (i = 0; i < nsl; i++) {
        nsi = nodesSnapshot.snapshotItem(i);
        callback(nsi);
    }
    return i;
};
atropa.xpath.removeNodesByXpath = function removeNodesByXpath(xpathExpression, contextNode, docref) {
    'use strict';
    atropa.supportCheck('xpath');
    var count;
    count = atropa.xpath.processNodesByXpath(xpathExpression, contextNode, docref, function (element) {
        atropa.removeNodeByReference(element);
    });
    return count;
};
atropa.xpath.getNodesByXpath = function getNodesByXpath(xpathExpression, contextNode, docref) {
    'use strict';
    atropa.supportCheck('xpath');
    var elementReferences;
    elementReferences = [];
    atropa.xpath.processNodesByXpath(xpathExpression, contextNode, docref, function (element) {
        elementReferences.push(element);
    });
    return elementReferences;
};
atropa.xpath.escapeQuotesXpath = function escapeQuotesXpath(string) {
    'use strict';
    string = string.replace(/\'/g, '\', "\'", \'');
    string = string.replace(/^(.*)$/g, 'concat(\'$1\')');
    return string;
};
while (atropa.data.requirements.length > 0) {
    atropa.data.requirements.pop()();
}
try {
    module.exports = atropa;
} catch (ignore) {
}