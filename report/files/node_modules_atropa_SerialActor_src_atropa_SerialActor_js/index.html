<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules\atropa-SerialActor\src\atropa-SerialActor.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules\atropa-SerialActor\src\atropa-SerialActor.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">355</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">25.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">0.80</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/// &lt;reference path=&quot;../docs/vsdoc/OpenLayersAll.js&quot;/&gt;
var atropa = require(&#039;atropa-header&#039;);
/*jslint 
    indent: 4,
    maxerr: 50,
    white: true,
    browser: true,
    devel: true,
    plusplus: true,
    regexp: true
*/
/*global atropa */
// end header

/**
 * A polling class designed for executing long running processes that return
 *  nothing and have no callback parameter.
 * @class A polling class designed for executing long running processes that
 *  return nothing and have no callback parameter.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130220
 * @param {String} actorName The name for the SerialActor instance.
 * @param {Function} actorFunction The function to execute when the
 *  SerialActor is free. This function must call the &lt;code&gt;free&lt;/code&gt; function
 *  when it is finished in order to allow the actor to continue.
 * @returns {atropa.SerialActor} Returns an &lt;code&gt;atropa.SerialActor&lt;/code&gt;
 *  instance.
 * @example
 * function dummyActor(){
 *     var that = this;
 *     console.log(&#039;actorFunction would execute&#039;);
 *     console.log(&#039;freeing &#039; + this.name + &#039; in 10000 ms&#039;);
 *     setTimeout(function(){that.free();}, 10000);
 * };
 * var actor = new atropa.SerialActor(&#039;dummy&#039;, dummyActor);
 *     // change the name of the actor from
 *     // dummy to awesome
 * actor.name = &quot;awesome&quot;;
 *     // set the polling interval (milliseconds)
 * actor.interval = 3000;
 *     // set the blocking timeout value (milliseconds)
 * actor.blockTimeoutValue = 120000;
 *     // start polling
 * actor.start();
 *     // dynamically change the SerialActor
 * setTimeout(function(){
 *     // change the polling interval
 *     // while the SerialActor is running.
 *     actor.changeInterval(2000);
 *         // change the actor function
 *     actor.actorFunction = function() {
 *         console.log(&#039;new actorFunction executing&#039;);
 *         console.log(&#039;freeing &#039; + this.name + &#039; immediately&#039;);
 *         this.free();
 *     };
 * },10000);
 */
atropa.SerialActor = function(actorName, actorFunction) {
    &quot;use strict&quot;;
    var that, dummyActor;
    /**
     * Reference to &lt;code&gt;this&lt;/code&gt;
     * @fieldOf atropa.SerialActor-
     * @private
     * @type {Object}
     */
    that = this;
    /**
     * Default actorFunction
     * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
     *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
     *  ☭ Hial Atropa!! ☭
     * @version 20130220
     * @methodOf atropa.SerialActor-
     * @private
     * @see atropa.SerialActor#actorFunction
     * @example
     * dummyActor = function(){
     *     console.log(&#039;actorFunction would execute&#039;);
     *     console.log(&#039;freeing Serial Actor in 10000 ms&#039;);
     *     setTimeout(function(){that.free();}, 10000);
     * };
     */
    dummyActor = function(){
        console.log(&#039;actorFunction would execute&#039;);
        console.log(&#039;freeing Serial Actor in 10000 ms&#039;);
        setTimeout(function(){that.free();}, 10000);
    };
    /**
     * The name of this instance. Defaults to &quot;SerialActor&quot;
     * @fieldOf atropa.SerialActor#
     * @type String
     * @default &quot;SerialActor&quot;
     */
    this.name = atropa.setAsOptionalArg(&#039;SerialActor&#039;, actorName);
    /**
     * Polling interval in milliseconds. This determines how frequently the
     *  actor function will try to execute. Defaults to 100 milliseconds.
     * @fieldOf atropa.SerialActor#
     * @type Number
     * @default 100
     */
    this.interval = 100; // milliseconds
    /**
     * The id of the interval set to poll the actor. You should not change
     *  this manually, use the start and stop functions instead. Defauls to
     *  undefined.
     * @fieldOf atropa.SerialActor#
     * @type Number
     * @default undefined
     */
    this.intervalId = undefined;
    /**
     * The state of the SerialActor. If true, the actor will sleep. If false the
     *  actor will execute the actor function when next polled. Defaults to
     *  false.
     * @fieldOf atropa.SerialActor#
     * @type Boolean
     * @default false
     */
    this.blocked = false;
    /**
     * Stores id&#039;s of currently running timeout functions used to free the actor
     *  if it has been blocked for too long.
     * @fieldOf atropa.SerialActor#
     * @see atropa.SerialActor#blockTimeoutValue
     * @type Array
     * @default []
     */
    this.timeouts = [];
    /**
     * The maximum time, in milliseconds, which the actor may be blocked for.
     *  After this duration has been reached the actor will be freed. Defaults
     *  to 60 seconds.
     * @fieldOf atropa.SerialActor#
     * @type Number
     * @default 60000
     */
    this.blockTimeoutValue = 60000;
    /**
     * The function to execute when the SerialActor is free. This function
     *  must call the &lt;code&gt;free&lt;/code&gt; function when it is finished in order to
     *  allow the actor to continue. Defaults to the &lt;code&gt;dummyActor&lt;/code&gt;
     *  function.
     * @fieldOf atropa.SerialActor#
     * @type Function
     * @default dummyActor
     * @see atropa.SerialActor-dummyActor
     * @example
     * dummyActor = function(){
     *     console.log(&#039;actorFunction would execute&#039;);
     *     console.log(&#039;freeing Serial Actor in 10000 ms&#039;);
     *     setTimeout(function(){that.free();}, 10000);
     * };
     */
    this.actorFunction = atropa.setAsOptionalArg(dummyActor, actorFunction);
    /**
     * The action function is called when the actor is polled and it&#039;s blocked
     *  state is false. This method should not be set or called manually, set
     *  the &lt;code&gt;actorFunction&lt;/code&gt; instead.
     * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
     *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
     *  ☭ Hial Atropa!! ☭
     * @version 20130220
     * @methodOf atropa.SerialActor#
     * @see atropa.SerialActor#actorFunction
     */
    this.action = function() {
        if(false === that.blocked) {
            that.block();
            setTimeout(function() {
                that.actorFunction();
            }, 10);
        } else {
            console.log(that.name + &#039; sleeping for &#039; + that.interval + &#039; ms&#039;);
        }
    };
};
/**
 * Prevents the actor from executing it&#039;s actorFunction. This block will timeout
 *  once the &lt;code&gt;blockTimeoutValue&lt;/code&gt; has been reached.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130220
 * @methodOf atropa.SerialActor#
 * @returns {Boolean} Returns the value of this instances &lt;code&gt;blocked&lt;/code&gt;
 *  property.
 * @see atropa.SerialActor#blocked
 * @example
 * function d() {
 *     console.log(&#039;doing stuff to things&#039;);
 *     this.free();
 * }
 * 
 * var actor = new atropa.SerialActor(&#039;dummy&#039;, d);
 * actor.interval = 2000;
 * actor.blockTimeoutValue = 5000;
 * actor.start();
 * // 5 seconds after starting the actor will be blocked.
 * // It will remain blocked until the block timeout is reached.
 * setTimeout(function() {
 *     console.log(&#039;blocking!!!&#039;);
 *     actor.block();
 * }, 5000);
 */
atropa.SerialActor.prototype.block = function() {
    &quot;use strict&quot;;
    var that = this;
    console.log(this.name + &#039; block&#039;);
    this.blocked = true;
    this.timeouts.push(
        setTimeout(function() {that.blockTimeout();}, that.blockTimeoutValue));
    return this.blocked;
};
/**
 * Called when the &lt;code&gt;blockTimeoutValue&lt;/code&gt; has been reached. This frees
 *  the actor and removes the timeout reference from the timeouts array.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130220
 * @methodOf atropa.SerialActor#
 * @returns {Boolean} Returns the value of this instances &lt;code&gt;blocked&lt;/code&gt;
 *  property.
 * @see atropa.SerialActor#blocked
 */
atropa.SerialActor.prototype.blockTimeout = function() {
    &quot;use strict&quot;;
    console.log(this.name + &#039; block timeout&#039;);
    return this.free();
};
/**
 * Frees the actor so it may execute its actor function when next polled.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130220
 * @methodOf atropa.SerialActor#
 * @returns {Boolean} Returns the value of this instances &lt;code&gt;blocked&lt;/code&gt;
 *  property.
 * @see atropa.SerialActor#blocked
 * @example
 * function d() {
 *     console.log(&#039;doing stuff to things&#039;);
 *     this.free();
 * }
 * 
 * var actor = new atropa.SerialActor(&#039;dummy&#039;, d);
 * actor.interval = 2000;
 * actor.blockTimeoutValue = 50000;
 * actor.start();
 * actor.block();
 * // 5 seconds after starting the actor will be freed.
 * setTimeout(function() {
 *     actor.free();
 * }, 5000);
 */
atropa.SerialActor.prototype.free = function() {
    &quot;use strict&quot;;
    console.log(this.name + &#039; free&#039;);
    this.blocked = false;
    clearTimeout(this.timeouts.shift());
    return this.blocked;
};
/**
 * Starts polling the actor.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130220
 * @methodOf atropa.SerialActor#
 * @param {Number} interval Optional. The polling interval. Defaults to the
 *  value of &lt;code&gt;this.interval&lt;/code&gt;
 * @see atropa.SerialActor#interval
 * @returns {Number} Returns the value of this instance&#039;s
 *  &lt;code&gt;intervalId&lt;/code&gt; property.
 * @see atropa.SerialActor#intervalId
 * @example
 * var actor = new atropa.SerialActor(&#039;dummy&#039;);
 * actor.start();
 */
atropa.SerialActor.prototype.start = function(interval) {
    &quot;use strict&quot;;
    var that = this;
    this.interval = atropa.setAsOptionalArg(this.interval, interval);
    
    if(this.intervalId !== undefined) {
        // clear the old timeout before creating a new one.
        this.stop();
    }
    this.intervalId = setInterval(that.action, that.interval);
    console.log(this.name + &#039; started&#039;);
    return this.intervalId;
};
/**
 * Adjusts the polling interval after &lt;code&gt;start&lt;/code&gt; has
 * been called.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130220
 * @methodOf atropa.SerialActor#
 * @param {Number} interval The new polling interval in milliseconds.
 * @returns {Number} Returns the value of this instance&#039;s 
 *  &lt;code&gt;intervalId&lt;/code&gt; property.
 * @see atropa.SerialActor#intervalId
 * @example
 * var actor = new atropa.SerialActor(&#039;dummy&#039;);
 * actor.start();
 *     // 5 seconds after starting the polling interval will be changed.
 * setTimeout(function(){
 *     actor.changeInterval(2000);
 * }, 5000);
 */
atropa.SerialActor.prototype.changeInterval = function(interval) {
    &quot;use strict&quot;;
    console.log(this.name + &#039; changing interval&#039;);
    return this.start(interval);
};
/**
 * Stops polling the actor. Note that the actor will be freed once the
 *  &lt;code&gt;blockTimeoutValue&lt;/code&gt; has been reached. This will not restart the
 *  polling.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130220
 * @methodOf atropa.SerialActor#
 * @see atropa.SerialActor#blocked
 * @see atropa.SerialActor#blockTimeoutValue
 * @example
 * var actor = new atropa.SerialActor(&#039;dummy&#039;);
 * actor.start();
 *     // 5 seconds after starting the actor will be stopped.
 * setTimeout(function(){
 *     actor.stop();
 * }, 5000);
 */
atropa.SerialActor.prototype.stop = function() {
    &quot;use strict&quot;;
    clearInterval(this.intervalId);
    this.intervalId = undefined;
    console.log(this.name + &#039; stopped&#039;);
};




while(atropa.data.requirements.length &gt; 0) {
    atropa.data.requirements.pop()();
}
module.exports = atropa;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
