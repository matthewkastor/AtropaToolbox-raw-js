<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap-3.0.0-wip.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>Toolbox\enabled\arrays.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="span6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">73.86</p>
    </div>
    <div class="span6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">397</p>
    </div>
  </div>
  <div class="row historical">
    <div class="span6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="span6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="span6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">44.22</p>
    </div>
    <div class="span6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">0.85</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="span6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="span6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="span12">/// &lt;reference path=&quot;../../docs/vsdoc/OpenLayersAll.js&quot;/&gt;
/*jslint
    indent: 4,
    maxerr: 50,
    white: true,
    browser: true,
    devel: true,
    plusplus: true,
    regexp: true
*/
/*global atropa */
// end header

/**
 * Utilities for handling arrays.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130221
 * @namespace Utilities for handling arrays.
 * @see &lt;a href=&quot;../../../AtropaToolboxTests.html?spec=atropa.arrays&quot;&gt;tests&lt;/a&gt;
 */
atropa.arrays = {};
/**
 * Compares two arrays based on size, contents, and element order.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20120909
 * @param {Array} array1 One array you want compared to another.
 * @param {Array} array2 The other array.
 * @returns {Boolean} Returns true or false depending on
 *  whether or not the arrays matched in size, composition, and
 *  element order.
 * @example
 * var x = [1,2];
 * var y = [1,1,3];
 * atropa.arrays.match(x,y);
 * // returns false
 * @example
 * var x = [1,2];
 * var y = [1,2];
 * atropa.arrays.match(x,y);
 * // returns true
 * @example
 * var x = [1,2];
 * var y = [2,1];
 * atropa.arrays.match(x,y);
 * // returns false because the elements are not in the same order.
 * @example
 * var x = [1,{&#039;aProp&#039; : &#039;aValue&#039;}];
 * var y = [1,{&#039;aProp&#039; : &#039;aValue&#039;}];
 * atropa.arrays.match(x,y);
 * // returns false because even though the object looks the same, the
 * // two objects are in fact distinct objects.
 * @example
 * var obj = {&#039;aProp&#039; : &#039;aValue&#039;};
 * var x = [1,obj];
 * var y = [1,obj];
 * atropa.arrays.match(x,y);
 * // returns true because the objects referenced in the arrays are
 * // in fact the same object.
 */
atropa.arrays.match = function arraysMatch(array1, array2) {
    &quot;use strict&quot;;
    var x,
    l;
    if (array1.length !== array2.length) {
        return false;
    }
    l = array1.length;
    for (x = 0; x &lt; l; x += 1) {
        if (array1[x] !== array2[x]) {
            return false;
        }
    }
    return true;
};
/**
 * Subtracts one array from another array based on the unique values in both
 *  sets.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130112
 * @param {Array} a (subtrahend) The array to subtract.
 * @param {Array} (minuend) fromB The array with elements duplicated in &lt;code&gt;a&lt;/code&gt;
 * @returns {Array} Returns a new array containing only the unique
 *  values found in &lt;code&gt;fromB&lt;/code&gt; that are not present in &lt;code&gt;a&lt;/code&gt;
 * @example
 * var x = [1,2];
 * var y = [1,1,3];
 * atropa.arrays.subtract(x,y);
 * // returns [3]
 * @example
 * var x = [1,3];
 * var y = [3,1];
 * atropa.arrays.subtract(x,y);
 * // returns []
 * @example
 * var x = [1,3];
 * var y = [3,1,1,9];
 * atropa.arrays.subtract(x,y);
 * // returns [9]
 * @example
 * var x = [1,3,{&#039;aProp&#039; : &#039;aVal&#039;}];
 * var y = [3,1,{&#039;aProp&#039; : &#039;aVal&#039;}];
 * atropa.arrays.subtract(x,y);
 * // returns [{&#039;aProp&#039; : &#039;aVal&#039;}] 
 * // because the two objects are not the same object.
 * @example
 * var obj = {&#039;aProp&#039; : &#039;aVal&#039;};
 * var x = [1,3,obj];
 * var y = [3,1,{&#039;aProp&#039; : &#039;aVal&#039;}];
 * atropa.arrays.subtract(x,y);
 * // returns [{&#039;aProp&#039; : &#039;aVal&#039;}] 
 * // because the two objects are not the same object.
 * @example
 * var obj = {&#039;aProp&#039; : &#039;aVal&#039;}
 * var x = [1,3,obj];
 * var y = [3,1,obj];
 * atropa.arrays.subtract(x,y);
 * // returns [] 
 * // because the objects referenced in the arrays are the same object.
 */
atropa.arrays.subtract = function(a, fromB) {
    &quot;use strict&quot;;
    var the = {};
    the.result = [];
    fromB.forEach(function(item){
        the.mark = false;
        a.forEach(function(rm){
            if(item === rm) {
                the.mark = true;
            }
        });
        if(the.mark !== true) {
            the.result.push(item);
        }
    });
    return the.result;
};
/**
 * Returns an array of values found in both of the given arrays.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130112
 * @param {Array} array1 An array.
 * @param {Array} array2 Another array.
 * @returns {Array} Returns an array of values found in both of the given
 *  arrays.
 * @example
 * var x = [1,3,4];
 * var y = [3,1,5];
 * atropa.arrays.intersect(x,y);
 * // returns [1,3]
 * @example
 * var x = [1,1,3,4];
 * var y = [3,1,1,5];
 * atropa.arrays.intersect(x,y);
 * // returns [1,1,3]
 * @example
 * var obj = {&#039;aProp&#039; : &#039;aVal&#039;};
 * var x = [1,3,obj];
 * var y = [3,1,obj];
 * atropa.arrays.intersect(x,y);
 * // returns [1,3,{&#039;aProp&#039; : &#039;aVal&#039;}]
 * @example
 * var obj = {&#039;aProp&#039; : &#039;aVal&#039;};
 * var x = [1,3,{&#039;aProp&#039; : &#039;aVal&#039;}];
 * var y = [3,1,obj];
 * atropa.arrays.intersect(x,y);
 * // returns [1,3] because the two objects are not the same object.
 * @example
 * var x = [1,3,{&#039;aProp&#039; : &#039;aVal&#039;}];
 * var y = [3,1,{&#039;aProp&#039; : &#039;aVal&#039;}];
 * atropa.arrays.intersect(x,y);
 * // returns [1,3] because the two objects are not the same object.
 */
atropa.arrays.intersect = function intersect(array1, array2) {
    &quot;use strict&quot;;
    var smallArray, largeArray, intersection = [];
    if(array1.length &gt; array2.length) {
        largeArray = array1.splice(0);
        smallArray = array2.splice(0);
    } else {
        largeArray = array2.splice(0);
        smallArray = array1.splice(0);
    }
    smallArray.forEach(function (item) {
        var idxInLargeArray = largeArray.indexOf(item);
        if (0 &lt;= idxInLargeArray) { // has word
            intersection.push(largeArray.splice(idxInLargeArray, 1)[0]);
        }
    });
    return intersection;
};
/**
 * Calculates the frequency of items occurring in an array.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130118
 * @param {Array} arr The array to calculate frequencies from.
 * @returns {Object} Returns an object whose keys are each unique
 *  elements from the array and their value is their frequency of
 *  occurrence within the array. Be careful that your array does
 *  not contain values matching object instance property names.
 * @example
 * var x = [1,1,1,1,1,3,3];
 * atropa.arrays.getFrequency(x);
 * // returns {
 * //     &quot;1&quot;: 5,
 * //     &quot;3&quot;: 2
 * // }
 * @example
 * var x = [&quot;bill&quot;, &quot;fred&quot;, &quot;fred&quot;, &quot;jane&quot;];
 * atropa.arrays.getFrequency(x);
 * // returns {
 * //     &quot;bill&quot;: 1,
 * //     &quot;fred&quot;: 2,
 * //     &quot;jane&quot;: 1
 * // }
 * @example
 * var x = [1,3,{&#039;aProp&#039; : &#039;aVal&#039;}];
 * atropa.arrays.getFrequency(x);
 * // returns {
 * //     &quot;1&quot;: 1,
 * //     &quot;3&quot;: 1,
 * //     &quot;[object Object]&quot;: 1
 * // }
 * @example
 * var obj = {&#039;aProp&#039; : &#039;aVal&#039;};
 * var otherObj = {};
 * var x = [1,3,obj,otherObj,{&#039;aDoughnut&#039; : &#039;sprinkles&#039;}];
 * atropa.arrays.getFrequency(x);
 * // returns {
 * //     &quot;1&quot;: 1,
 * //     &quot;3&quot;: 1,
 * //     &quot;[object Object]&quot;: 3
 * // }
 * @example
 * var x = [1,3,&quot;toString&quot;];
 * atropa.arrays.getFrequency(x);
 * // returns {
 * //     &quot;1&quot;: 1,
 * //     &quot;3&quot;: 1,
 * //     &quot;toString&quot;: &quot;function toString() {\n    [native code]\n}1&quot;
 * // }
 */
atropa.arrays.getFrequency = function (arr) {
    &quot;use strict&quot;;
    var out = arr.reduce(function (acc, curr) {
        if (acc[curr] === undefined) {
            acc[curr] = 1;
        } else {
            acc[curr] += 1;
        }
        return acc;
    }, {});
    return out;
};
/**
 * Gets Unique values from an array.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130118
 * @param {Array} largeArray The array with duplicate values in it.
 * @returns {Array} Returns a new array containing only the unique
 *  values found in the largeArray.
 * @example
 * var x = [1,1,1,4,4,3,6];
 * atropa.arrays.getUnique(x);
 * // returns [ &quot;1&quot;, &quot;4&quot;, &quot;3&quot;, &quot;6&quot; ]
 * @example
 * var x = [&quot;bill&quot;, &quot;fred&quot;, &quot;jane&quot;, &quot;fred&quot;];
 * atropa.arrays.getUnique(x);
 * // returns [&quot;bill&quot;, &quot;fred&quot;, &quot;jane&quot;]
 * @example
 * var x = [ 
 *     &quot;bill&quot;,
 *     {&quot;aProp&quot; : &quot;aValue&quot;},
 *     {&quot;aGuy&quot; : &quot;fred&quot;},
 *     {&quot;aLady&quot; : &quot;jane&quot;}
 * ];
 * atropa.arrays.getUnique(x);
 * // returns [ &quot;bill&quot;, &quot;[object Object]&quot; ]
 */
atropa.arrays.getUnique = function (largeArray) {
    &quot;use strict&quot;;
    return Object.keys(atropa.arrays.getFrequency(largeArray)).sort();
};
/**
 * Removes empty strings from the given array.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130118
 * @param {Array} arrayWithEmptyElements The array with empty strings in it.
 * @returns {Array} Returns a new array with empty strings removed.
 * @example
 * var x = [ 10, , 5, &quot;&quot;, &#039;&#039;, 7 ];
 * console.log(&#039;starting length &#039; + x.length);
 * console.log(x);
 * x = atropa.arrays.removeEmptyElements(x);
 * console.log(&#039;ending length &#039; + x.length);
 * console.log(x);
 * // displays the following
 * // starting length 6
 * // [10, undefined, 5, &quot;&quot;, &quot;&quot;, 7]
 * // ending length 3
 * // [10, 5, 7]
 */
atropa.arrays.removeEmptyElements = function (arrayWithEmptyElements) {
    &quot;use strict&quot;;
    return arrayWithEmptyElements.filter(function (item) {
        return !atropa.inquire.isEmptyString(item);
    });
};
/**
 * Reindexes an array.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130118
 * @param {Array} arr The array with discontinuous keys.
 * @returns {Array} Returns an array with continuous keys.
 * @example
 * var x = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, undefined ];
 * console.log(x); // [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, undefined ]
 * console.log(x.length); // 4
 * 
 * delete x[1]; // deletes the key from the array but
 *              // the array length remains the same
 *              // at this point the arrays keys are 0, 2, and 3
 * console.log(x); // [ &quot;a&quot;, undefined, &quot;c&quot;, undefined ]
 * console.log(x.length); // 4
 * 
 * x = atropa.arrays.reindex(x);
 * console.log(x); //  [ &quot;a&quot;, &quot;c&quot;, undefined ]
 *    // note that the last element existed in the array, its value was
 *    // undefined but it did have a key so the element remains in the array.
 *    //
 *    // The deleted element was in fact deleted from the array so there was no
 *    // key x[1] at all, when trying to access this non existing element the
 *    // value of undefined was returned. This behavior is confusing unless you
 *    // think about the arrayas an object whose properties are named by
 *    // numbers. Accessing an undefined property returns undefined regardless
 *    // of whether the property existed in the past or not.
 * console.log(x.length); // 3
 */
atropa.arrays.reindex = function reindex(arr) {
    &quot;use strict&quot;;
    var idx, out;
    out = [];
    for(idx in arr) {
        if(arr.hasOwnProperty(idx)) {
            out.push(arr[idx]);
        }
    }
    return out;
};
/**
 * Sorts an array&#039;s elements numerically.
 * @author &lt;a href=&quot;mailto:matthewkastor@gmail.com&quot;&gt;
 *  Matthew Christopher Kastor-Inare III &lt;/a&gt;&lt;br /&gt;
 *  ☭ Hial Atropa!! ☭
 * @version 20130120
 * @param {Array} arr The array to sort. All elements of the array must be
 *  number-ish.
 * @returns {Array} Returns an array whose elements are in numeric order.
 * @example
 * var x = [3, 2, 9, 26, 10, 1, 99, 15];
 * console.log( atropa.arrays.sortNumerically(x) );
 * // logs [1, 2, 3, 9, 10, 15, 26, 99]
 */
atropa.arrays.sortNumerically = function sortNumerically(arr) {
    &quot;use strict&quot;;
    return arr.sort(function (a, b) {
        return (a - b);
    });
};
/**
 * Throws an error, &lt;code&gt;String.prototype.localeCompare&lt;/code&gt; is not 
 *  standardized.
 * 
 *  Yes, localeCompare is in the standard but, at this time the actual
 *  comparison is implementation dependant. This means that &quot;alphabetical order&quot;
 *  can be different on different platforms. What I found was that in node the
 *  array of &lt;code&gt;[&#039;a&#039;,&#039;Z&#039;,&#039;A&#039;,&#039;z&#039;]&lt;/code&gt; would be sorted to
 *  &lt;code&gt;[&#039;A&#039;,&#039;Z&#039;,&#039;a&#039;,&#039;z&quot;]&lt;/code&gt;, while on
 *  firefox it would be sorted to &lt;code&gt;[&#039;a&#039;,&#039;A&#039;,&#039;z&#039;,&#039;Z&#039;]&lt;/code&gt;. Who knows if
 *  another implementor would sort it &lt;code&gt;[&#039;A&#039;,&#039;a&#039;,&#039;Z&#039;,&#039;z&#039;]&lt;/code&gt;?
 * 
 * In order to provide a reliable implementation I would have to create my own
 *  implementation of &lt;code&gt;String.prototype.localeCompare&lt;/code&gt; and that&#039;s
 *  just too much work for me to do alone.
 * @throws {Error} &quot;String.prototype.localeCompare is not standardized&quot;
 */
atropa.arrays.sortAlphabetically = function sortAlphabetically(arr) {
    &quot;use strict&quot;;
    throw new Error(&quot;String.prototype.localeCompare is not standardized&quot;);
};
/**
 * Deletes the given element from the array at the given index. It basically
 *  does what you would expect the delete operator to do, except the delete
 *  operator doesn&#039;t do what you would expect.
 * @param {Array} arr The array.
 * @param {Number} index The index of the element to delete.
 * @returns Returns an array with the element removed, contiguous keys, and
 *  whose length is 1 less than the input array.
 */
atropa.arrays.deleteElement = function (arr, index) {
    &quot;use strict&quot;;
    delete arr[index];
    return atropa.arrays.reindex(arr);
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
