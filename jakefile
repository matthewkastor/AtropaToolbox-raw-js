"use strict";
var platoLocation = 'node_modules/.bin/plato';
/**
 * Jake will automatically look for files with a .jake extension in a 
 *  'jakelib' directory in your project, and load them (via require) after 
 *  loading your Jakefile. 
 * 
 * Running jake with no arguments runs the default task.
 * The base 'jake' object is an EventEmitter, and fires a 'complete' event 
 *  after running all tasks.
 * 
 * To show the list of defined tasks run jake with the -T or --tasks flag 
 *  from the command line.
 *
 * Use task to define tasks.
 *  Tasks are EventEmitters. They can fire 'complete' and 'error' events.
 *  The 'complete' event is fired when the task is finished.
 *  The 'error' event is fired when there is an error.
 * 
 * task(
 *  {String} name The name of the task.
 *  {Array} prerequisites An array of task names to be performed before this
 *                        task.
 *  {Function} action The task to complete. "This" refers to the task object.
 *  {Object} opts Options object.
 * );
 * 
 * Use desc to add a string description of the task.
 * 
 * desc(
 *  {String} description The description of a task.
 * );
 * 
 * @example default task
 *  desc('This is the default task.');
 *  task('default', function (params) {
 *    console.log('This is the default task.');
 *  });
 * 
 * @example task with prerequisites
 *  desc('This task has prerequisites.');
 *  task('hasPrereqs', ['foo', 'bar', 'baz'], function (params) {
 *    console.log('Ran some prereqs first.');
 *  });
 * 
 * @example asynchronous task
 * When a task's operations are asynchronous, the async property should be 
 *  set to true, and the task must call complete() to signal to Jake that 
 *  the task is done, and execution can proceed. By default the async 
 *  property is false.
 * 
 *  desc('This is an asynchronous task.');
 *  task('asyncTask', {async: true}, function () {
 *    setTimeout(complete, 1000);
 *  });
 */

/*jslint
    indent: 4,
    maxerr: 50,
    white: true,
    browser: true,
    devel: true,
    plusplus: true,
    regexp: true,
    node: true,
    stupid: true
*/

/*globals
    desc,
    task,
    complete
*/

/**
 * Concatenates files and optionally lets you preprocess each file.
 * @function
 * @param {Array} arr An array of file paths to concatenate.
 * @param {Function} processFn Optional. An optional function to preprocess
 *  each file with. The function will be called with the string value of the
 *  file and the path to the file. The return value of this function will be
 *  used as the string which is concatenated.
 * @example
 *  function processFn (fileContents, filePath) {
 *      if(filePath === 'some/file/path/file.txt') {
 *          return fileContents.replace(/a/gi, 'A');
 *      } else {
 *          return fileContents;
 *      }
 *  }
 *  var concated = concatFiles(['some/file/path/file.txt'], processFn);
 *  console.log(concated);
 */
function concatFiles (arr, processFn) {
    if(typeof processFn !== 'function') {
        processFn = function (fileContents) {
            return fileContents;
        };
    }
    
    var fs, out, fileContents, filePath;
    
    fs = require('fs');
    out = '';
    fileContents = '';
    filePath = '';
    
    arr.forEach(function (item) {
        fileContents = fs.readFileSync(item, 'utf8');
        filePath = item;
        out += processFn(fileContents, filePath);
        fileContents = '';
        filePath = '';
    });
    return out;
}

/**
 * Removes everything between "///" and "// end header" inclusive.
 * @param {String} str The string to remove the header from.
 * @returns {String} Returns a string with the header removed.
 */
function removeHeader(str) {
    return str.replace(/^\/\/\/[\s\S]+\/\/ end header[\s]+/, '\r\n');
}

/**
 * Creates a directory if it does not exist.
 * @param {String} dirName The name of the directory.
 */
function mkdir (dirName) {
    var fs;
    fs = require('fs');
    if(!fs.existsSync(dirName)) {
        fs.mkdirSync(dirName);
    }
}

/**
 * Removes a directory if it exists regardless of whether or not it is empty.
 * @param {String} dirName the name of the directory.
 */
function rmdir (dirName) {
    var fs, wrench;
    
    fs = require('fs');
    wrench = require('wrench');
    if(fs.existsSync(dirName)) {
        wrench.rmdirSyncRecursive(dirName);
    }
}

/**
 * Gets an AST from esprima
 * @param {String} filePath The path to the JavaScript file you want parsed.
 * @param {Object} optons Optional. The options argument accepted by
 *  esprima.parse.
 * @returns {Object} Returns an object representing the AST.
 */
function generateAST (filePath, options) {
    var fs, path, esprima, location, source, ast;
    fs = require('fs');
    path = require('path');
    esprima = require('esprima');
    
    location = path.normalize(filePath);
    source = fs.readFileSync(location);
    ast = esprima.parse(source, options);
    
    return ast;
}

function simplifyJs(pathName, options) {
    var fs, path, escodegen, out;
    
    options = options || {
        format: {
            indent: {
                style: '    ',
                base: 0
            },
            json: false,
            renumber: false,
            hexadecimal: false,
            quotes: 'single',
            escapeless: false,
            compact: false,
            parentheses: true,
            semicolons: true
        },
        parse: null,
        comment: false,
        sourceMap: undefined
    };
    
    fs = require('fs');
    path = require('path');
    escodegen = require('escodegen');
    
    out = fs.readFileSync(
        path.normalize('Toolbox/headers/atropaToolboxLinting.js'),
        'utf8'
    );
    
    out += escodegen.generate(generateAST(pathName), options);
    
    return out;
}

desc('An alias for the build task.');
task('default', ['build'], function () {
});

desc('Builds AtropaToolbox, test runner, and docs.');
task(
    'build',
    [
        'makeAtropaToolbox',
        'generateDocs',
        'min',
        'jasmineRunnerGen'
    ],
    function () {
        console.log('built');
    }
);

desc('Generates AtropaToolbox.js.');
task('makeAtropaToolbox', function () {
    var fs, path, headers, toolboxComponentsLocation, componentNames,
        components, toolbox, outputFilePath;
    fs = require('fs');
    path = require('path');
    headers = [
        path.normalize('Toolbox/headers/atropaToolboxHeader.js'),
        path.normalize('Toolbox/headers/atropaHeader.js')
    ];
    toolboxComponentsLocation = path.normalize('Toolbox/enabled/');
    componentNames = fs.readdirSync(toolboxComponentsLocation);
    components = componentNames.map(function(item){
        return path.normalize(toolboxComponentsLocation + item);
    });
    toolbox = '/// <reference path="../../docs/vsdoc/OpenLayersAll.js"/>\r\n';
    toolbox += fs.readFileSync(
        path.normalize('Toolbox/headers/atropaToolboxLinting.js'),
        'utf8'
    );
    toolbox += concatFiles(headers.concat(components), removeHeader);
    toolbox += fs.readFileSync(
        path.normalize('Toolbox/footers/atropaFooter.js'),
        'utf8'
    );
    outputFilePath = path.normalize('src/AtropaToolbox.js');
    rmdir('src');
    mkdir('src');
    fs.writeFileSync(outputFilePath, toolbox, 'utf8');
});

desc('Generates AtropaToolbox.min.js.');
task('min', ['makeAtropaToolbox'], function (options) {
    var fs, path, simple;
    
    fs = require('fs');
    path = require('path');
    
    simple = simplifyJs(path.normalize('src/AtropaToolbox.js'), options);
    
    fs.writeFileSync(path.normalize('src/AtropaToolbox.min.js'), simple, 'utf8');
});

desc('Displays an AST of the AtropaToolbox.');
task('generateAST', ['makeAtropaToolbox'], function (options) {
    var ast = generateAST('src/AtropaToolbox.js', options);
    ast = JSON.stringify(ast, null, '    ');
    console.log(ast);
});

desc('Generates reports docs/jsdoc and docs/vsdoc.');
task('generateDocs', ['makeAtropaToolbox'], {async : true}, function () {
    var path, cmd, register, platoCmd;
    
    path = require('path');
    cmd = require('atropa-cmd');
    
    rmdir('logs');
    rmdir('docs');
    //rmdir('report');
    
    mkdir('logs');
    
    register = new cmd.commandRegister.Asynchronous('Generate Docs');
            
    register.on('command queue begin process', function(e) {
        console.log('command queue begin process');
        console.dir(e);
        console.log();
    });
    register.on('command executing', function(e) {
        console.log('command executing');
        console.dir(e);
        console.log();
    });
    register.on('command complete', function(e) {
        console.log('command complete');
        console.dir(e);
        console.log();
    });
    register.on('waiting for commands to complete', function(e) {
        console.log('waiting for commands to complete');
        console.dir(e);
        console.log();
    });
    register.on('command queue processed', function(e) {
        console.log('command queue processed');
        console.dir(e);
        console.log();
        complete();
    });
    
    function logOutput(err, stdout, stderr) {
        if(stdout) {
            console.log(stdout);
        }
        if(stderr) {
            console.error(stderr);
        }
        if(err) {
            console.error(err);
        }
    }
    
    function dQuote (arg) {
        return '"' + arg + '" ';
    }
    function pathArg (str) {
        return dQuote(path.normalize(str));
    }
    function jvsdocCmdGen (jOrV) {
        var jsdocToolkitLoc, cmd;
        jsdocToolkitLoc = path.resolve('buildTools/jsdoc_toolkit-2.4.0/');
        cmd = 'java -jar ' +
            pathArg(jsdocToolkitLoc + '/jsrun.jar') +
            pathArg(jsdocToolkitLoc + '/app/run.js') +
            '-r=10 ' +
            '-a ' +
            '-p ' +
            '-d=' + pathArg('docs/' + jOrV) +
            '-o=' + pathArg('logs/' + jOrV + '-toolkit-error-log.txt') +
            '-t=' + pathArg(jsdocToolkitLoc + '/templates/' + jOrV) +
            dQuote(path.normalize('src/AtropaToolbox.js'));
        
        return cmd.trim();
    }
    
    platoCmd = path.normalize(platoLocation) + ' --recurse ' +
        '--title "Code Analysis of The Glorious AtropaToolbox" ' +
        '--dir report ' + path.normalize('Toolbox/enabled');
        
    register.addCommand(platoCmd, null, logOutput);
    register.addCommand(jvsdocCmdGen('jsdoc'), null, logOutput);
    register.addCommand(jvsdocCmdGen('vsdoc'), null, logOutput);
    register.process();
});

desc('Update JsLint');
task('JsLintUpdate', function () {
    var jslint = require('atropa-jslint');
    jslint.update();
});

desc('Rollback JsLint Update');
task('JsLintRollbackUpdate', function () {
    var jslint = require('atropa-jslint');
    jslint.rollbackUpdate();
});

desc('Runs JsLint on AtropaToolbox.js');
task('RunJsLint', ['makeAtropaToolbox'], function () {
    var os, fs, path, jslint, source;
    
    os = require('os');
    fs = require('fs');
    path = require('path');
    jslint = require('atropa-jslint');
    
    source = fs.readFileSync(path.normalize('src/AtropaToolbox.js'), 'utf8');
    if(jslint.JSLINT(source)) {
        console.log('Success, no errors to report.');
    } else {
        jslint.JSLINT.errors.forEach(function (error) {
            console.error(
                '* Error:' + os.EOL +
                '    Reason: ' + error.reason + os.EOL +
                '    Evidence: ' + error.evidence + os.EOL +
                '    Line: ' + error.line + os.EOL +
                '    Char: ' + error.character + os.EOL + os.EOL);
        });
    }
});

desc('Starts the doc server at docServ[port] or 8888.');
task('docServ', function (port) {
    
    port = port || 8888;
    
    var fs, path, cmd, atropaServer, gen, register;
    
    fs = require('fs');
    path = require('path');
    cmd = require('atropa-cmd');
    atropaServer = require('atropa-server');
    gen = require('./buildTools/mustache/RedirectToLocalhost.mustache.js');
    
    function logOutput(err, stdout, stderr) {
        if(stdout) {
            console.log(stdout);
        }
        if(stderr) {
            console.error(stderr);
        }
        if(err) {
            console.error(err);
        }
    }
    
    gen.generateRedirectToLocalhostHtml(port);
    
    register = new cmd.commandRegister.Asynchronous(
        'Load documentation server');
    register.on('command queue processed', function() {
        setTimeout(function () {
            try {
                fs.unlink('RedirectToLocalhost.html');
            } catch (e) {
                console.error(e);
            }
        }, 10000);
    });
    register.addCommand('RedirectToLocalhost.html', null, logOutput);
    register.process();
    
    atropaServer.start(port, __dirname);
});

desc('Regenerates AtropaToolboxTests.html');
task('jasmineRunnerGen', function () {
    var JasmineSpecRunnerGenerator, specRunner;
    
    JasmineSpecRunnerGenerator = require(
         'atropa-jasmine-spec-runner-generator-html');
    
    specRunner = new JasmineSpecRunnerGenerator(
         'jasmine/', 'AtropaToolboxTests.html', 'AtropaToolbox Test Suite');
    
    specRunner.sourceFiles = ['src/AtropaToolbox.js'];
    
    specRunner.addSpecs('./Toolbox/test/enabled/', 'Toolbox/test/enabled/');
    
    // specRunner.generate(console.log);
    
    specRunner.generateFile(
        function () {
            console.log('Generated AtropaToolboxTests.html');
        }
    );
});


